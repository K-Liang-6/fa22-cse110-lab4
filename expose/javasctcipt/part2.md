1.Print "3" to the console. This is the value of the "i" after the increasing cycle variable, which is equal to the length of the "price" array.Since we use VAR to make "i", it has a functional range, so we can visit it outside the cycle.

2.Print "150" to the console. This is the last discount in the "price" array, so it "save" it into the 'discoundedprice' variable.Similarly, the variable has a functional range, so we can print outside the cycle.

3.Print "150" to the console. This is the same value as the last value, and line 14 of the code helps a circular Deciaml value. Since the final price is an integer, there is no change, and all the reasons for printing are the same as the last problem.

4.Function will return an array [50, 100,150]. In essence, this is the correct output of this function. We apply 50 % discount to all input prices and return a new array of the same length at the discount price.Due to the errors of the cycle, the code runs as expected, providing us with a 0.5 times original price as output.

5.The code contains an error, because "i" is declared in a block, we cannot access it outside the cycle.

6.The code contains an error again,  because the "DiscounteDPrice" has a block, we cannot access it outside the cycle.

7.It print "150" to the console.Since 'FinalPrice' has a function range (it has a block, but the block of the statement is the entire function), we can print it as last time.Therefore, we printed the final discount price from the input array.

8.The code will return [50, 100 ,150], just like last time. This is because in this case, the scope of each variable does not change the execution of the code, because all variables are changed in its own block.

9.Code is wrong, because "I" is declared in a block, we cannot access it outside the cycle.

10.It print "3" to the console."Length" is the constant within the scope of the printing item, and we never allocate it.Therefore, the code is executed and output "3" as expected.

11.It will return [50, 100 ,150].Â We may think that the announcement of the "discount" array as a constant will cause problems, but this is just an announcement as an unchanged reference. As long as we do not try to reassign "discounts", we can still change the constant array.Therefore, the code is executed as expected to give the same output as the last time.

12.A. student.name <br />
   B. student['Grad Year'] <br />
   C. student.greeting() <br />
   D. student['Favorite Teacher'].name<br />
   E. student.courseload[0]<br />

13.A.'32' When we involve a string, we connect the string of the integer.<br />
   B. 1 when we use the subtraction operator, there is no string conversion.All parameters are converted to numbers and minus <br />
   C. 3 Null interpretation as zero, and it is normal<br />
   D. "3null" it has converted the parameter to string and connection because it involves a string.<br />
   E. 4 True is explained as 1, and it is normal.<br />
   F. 0 False and NULL are interpreted as 0, and it is added to normal.<br />
   G.'3undefined'it is converted to string and connecting the parameters as a string involved a string.<br />
   H. NAN No string conversion is done as we use the subtraction operator. All arguments are converted to numbers, but 'undefined' cannot be converted properly. So, subtraction results in 'Not a Number'.<br />

14.A. T We convert two parameters to numbers and compare it as expected.<br />
   B. T The string is compared in the sequence of the dictionary because the "12 'appears in the" 2' in the dictionary, and the output is true.<br />
   C. T We convert two parameters to numbers and compare it as expected.<br />
   D. F '===' The operating symbol does not perform type conversion, so when we compare the string directly with the integer, we get false.<br />
   E. F True is converted to 1, which is performed as usual.<br />
   F. F Boolean (2) explicitly outputs a Boolean value 'true', which is compared with another Boolean value 'true'.<br />

15.'==' The operator will execute the type conversion so that the two parameters have the same type, and then perform the comparison according to the type.'===' The operator also compares the type of two parameters, which means that if the parameters have different beginning types, they are not equal.

16.see p2-qs16.js

17.The dosomething function that is passed as an argument is a function that takes a number and returns a number and the arguments to the dosomething function double them so if we were to print the output, we would get an array of the same length as the input array with twice as many elements.

18.see p2-qs18.js

19.The output is 1 4 3 2
